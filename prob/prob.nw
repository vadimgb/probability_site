\href{prob.zip}{Исходный код к теме}
\section{Дискретное распределение}
Бросим n раз монету, пусть m раз выпал орёл.
f = m/n -  частота выпадения орла.
Это - случайная величина, 
Исследуем её при помощи компьютерной симуляции. 
Для этого нам понадобится модуль random, он содержит 
генераторы псевдослучайных значений.
Например
\begin{lstlisting}[language=Python]
<<prob.py>>=
from random import choices
res = choices([0, 1], k = 10)
print(res)
@
\end{lstlisting}
res будет содержать список из k нулей и единиц,
с генерированных псевдослучайно.

[[1, 0, 1, 1, 1, 0, 1, 0, 1, 0]]

Единицу будем считать выпадением орла на монете,
а 0 - решки.
\begin{lstlisting}[language=Python]
<<prob.py>>=
def flips(nFlips):
	'''nFlips число бросаний монеты,
	возвращает h - частоту выпадения орла.'''
	res = choices([0, 1], k = nFlips)
	h = sum(res)/nFlips 
	return  h
@
\end{lstlisting}
Для начала будем бросать по 10 раз и записывать частоту.
Проведём это опыт 8 раз
\begin{lstlisting}[language=Python]
<<prob.py>>=
res = [flips(10) for k in range(8)]
print(res)
@
\end{lstlisting}
получили

[[0.5, 0.4, 0.6, 0.5, 0.7, 0.3, 0.8, 0.6]]

Мы видим что частота имеет сильно различающиеся значения.
Разница между самым большим 0.8 и самым маленьким 0.3, 
равна 0.5. 

Будем бросать монету 1000 раз и записывать частоту.
\begin{lstlisting}[language=Python]
<<prob.py>>=
res = [flips(1000) for k in range(8)]
print(res)
@
\end{lstlisting}
получили
\begin{lstlisting}[language=Python]
<<>>=
[0.515, 0.484, 0.522, 0.498, 0.498, 0.513, 0.511, 0.486]
@
\end{lstlisting}
Значения близки к 0.5, их разброс стал гораздо меньше.
Самая большая разница равна 0.038.
Мы получили, что при увеличении числа бросаний,
частота стремиться к некоторому пределу, 
назовём его  вероятностью выпадения орла.



Выпадение орла или решки называют элементарными событиями. 
При бросании кубика элементарными событием будет, например,
выпадение 1. Все элементарные события образуют множество 
событий (мир). 
Всякое подмножество  множества
событий будем называть событием. 
Так событие выпадение чётного числа на кубике - это 
подмножество [2, 4, 6]. Если множество событий дискретное,
то мы можем задать для каждого элементарного события его 
вероятность. Эту функцию называют дискретным распределением вероятностей.
Множество событий с заданным на нем распределением вероятностей 
называют
вероятностным пространством. А элементарные события можно назвать
точками вероятностного пространства.
Вероятностное пространство введено для формализации понятия вероятности.

На событиях мы можем задать операции 
сложения(\(+, \cup\)) и умножения (\(*,\cap\)).
\(A \cup B\) произошло \(A\) или \(B\).  
\(A \cap B\) произошло \(A\) и \(B\). 

Приведём аксиомы вероятности.
\begin{itemize}
\item Если \(A\) и \(B\) несовместны, т.е.  \(A * B= \varnothing\)
то
	$$ P(A + B) = P(A) + P(B) $$
\item Если U множество событий, то
	$$ P(U) = 1 $$
\item
	$$ P(\varnothing) = 0 $$
\end{itemize}

Чтобы придать точность понятию дискретное вероятностное пространство,
определим его в python, как класс DDist. 
\begin{lstlisting}[language=Python]
<<ddist.py>>=
from random import random 
<<вспомогательные функции>>
class DDist:
	def __init__(self, dictionary):
		'''dictionary - словарь, в нем 
		ключи - элементарные события, 
		значения их вероятности'''
		self.d = dictionary
	def prob(self, k):
		'''вычисляет вероятность элементарного события k'''
		if k in self.d:
			return self.d[k]
		else:
			return 0
	def draw(self):
		'''генерирует псевдослучайное элементарное событие'''
		x = random()
		help = 0
		for k in self.d:
			help += self.d[k]
			if help > x:
				return k
	def trials(self, nTrials):
		'''вычисляет список из nTrials псевдослучайных событий'''
		return [self.draw() for k in range(nTrials)]
	def __repr__(self):
		return str(self.d)
	<<маргинальное распределение>>
	<<условие на переменную>>
@
\end{lstlisting}
