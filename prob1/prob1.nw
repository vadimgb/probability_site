<p><a href="prob.zip">Исходный код к теме</a>
<h2>Дискретное распределение</h2>
<p>Бросим n раз монету, пусть m раз выпал орёл.
f = m/n -  частота выпадения орла.
Исследуем её при помощи компьютерной симуляции. 
Для этого нам понадобится модуль random, он содержит 
генераторы пседвослучайных значений.
</p>
<pre>
<<prob1.py>>=
from random import choices
res = choices([0, 1], k = 10)
print(res)
@
</pre>
<p>res будет содержать список из k нулей и единиц,
с генерированных псевдослучайно.</p>
<p>[1, 0, 1, 1, 1, 0, 1, 0, 1, 0]</p>
</p>Единицу будем считать выпадением орла на монете,
а 0 - решки.
<pre>
<<prob1.py>>=
def flips(nFlips):
	'''nFlips число бросаний монеты,
	возвращает h - частоту выпадения орла.'''
	res = choices([0, 1], k = nFlips)
	h = sum(res)/nFlips #sum(res) число выпадений орла 
	return  h
@
</pre>
<p>Сначала будем бросать по 10 раз и записывать частоту.
Проведём этот опыт 8 раз.</p>
<pre>
<<prob1.py>>=
res = [flips(10) for k in range(8)]
print(res)
@
</pre>
<p>Получили</p>
<p>[0.5, 0.4, 0.6, 0.5, 0.7, 0.3, 0.8, 0.6]</p>
<p>Мы видим что частота имеет сильно различающиеся значения.
Разница между самым большим 0.8 и самым маленьким 0.3, 
равна 0.5.</p> 
<p>Будем бросать монету 1000 раз и записывать частоту.</p>
<pre>
<<prob1.py>>=
res = [flips(1000) for k in range(8)]
print(res)
@
</pre>
<p>получили</p>
<p>[0.515, 0.484, 0.522, 0.498, 0.498, 0.513, 0.511, 0.486]</p>
<p>Значения близки к 0.5, их разброс стал гораздо меньше.
Самая большая разница равна 0.038.
Мы получили, что при увеличении числа бросаний,
частота стремиться к некоторому пределу, 
назовём его  вероятностью выпадения орла.
</p>


<p>Выпадение орла или решки называют элементарными событиями. 
При бросании кубика элементарными событием будет, например,
выпадение 1. Все элементарные события образуют множество 
событий (мир). 
Всякое подмножество  множества
событий будем называть событием. 
Так событие выпадение чётного числа на кубике - это 
подмножество [2, 4, 6]. Если множество событий дискретное,
то мы можем задать для каждого элементарного события его 
вероятность. Эту функцию называют дискретным распределением вероятностей.
Множество событий с заданным на нем распределением вероятностей 
называют
вероятностным пространством. А элементарные события можно назвать
точками вероятностного пространства.
Вероятностное пространство введено для формализации понятия вероятности.
</p>
<p>На событиях мы можем задать операции 
сложения(\(+, \cup\)) и умножения (\(*,\cap\)).
\(A \cup B\) произошло \(A\) или \(B\).  
\(A \cap B\) произошло \(A\) и \(B\). </p>
<p>Приведём аксиомы вероятности.</p>
<ul> 
<li>Если \(A\) и \(B\) несовместные, т.е.  \(A * B= \varnothing\)
то
$$
	P(A + B) = P(A) + P(B) 
$$</li>
<li>
Если U множество событий, то
$$
	P(U) = 1
$$
</li>
<li>
$$
	P(\varnothing) = 0
$$</li>
</ul>
<p>Чтобы придать точность понятию дискретное вероятностное пространство,
определим его в python, как класс DDist. </p>
<pre><code>
<<ddist.py>>=
from random import random 
<<вспомогательные функции>>
class DDist:
	def __init__(self, dictionary):
		'''dictionary - словарь, в нем 
		ключи - элементарные события, 
		значения их вероятности'''
		self.d = dictionary
	def prob(self, k):
		'''вычисляет вероятность элементарного события k'''
		if k in self.d:
			return self.d[k]
		else:
			return 0
	def draw(self):
		'''генерирует псевдослучайное элементарное событие'''
		x = random()
		help = 0
		for k in self.d:
			help += self.d[k]
			if help > x:
				return k
	def trials(self, nTrials):
		'''вычисляет список из nTrials псевдослучайных событий'''
		return [self.draw() for k in range(nTrials)]
	def __repr__(self):
		return str(self.d)
	<<маргинальное распределение>>
	<<условие на переменную>>
	<<условное распределение>>
@
</code>
</pre>
Так для бросания монеты получаем.
<pre><code>
<<prob1.py>>=
import ddist
#H орёл, T - решка.
dm = ddist.DDist({"H":1/2, "T":1/2})
print(dm.trials(8))
@
</code></pre>
Получаем
<p>
['H', 'H', 'H', 'T', 'T', 'T', 'T', 'T']
</p>
<h2>Маргинальное (частное) распределение</h2>
<p>В геометрии положение точки на плоскости
удобно задавать при помощи двух переменных
x и y. Также и теории вероятности элементарное
событие иногда удобно задавать при помощи
нескольких случайных переменных. 
Распределение в таком случае будем называть совместным
распределением случайных переменных.
Так при
бросании двух монет удобно
использовать пару случайных переменных
принимающих значения орёл или решка.
Если задано совместное распределение P(A,B)
двух случайных переменных A, B, мы можем
рассмотреть отдельно распределение величины A.
Такое распределение называется маргинальным
или частным. И оно будет задаваться формулой
$$
P(a) = \sum_{b \in B} P(a, b)
$$
Большой буквой обозначаем случайную переменную,
а маленько её значение.
Добавим метод  в определение класса
DDist.</p>
<pre>
<<маргинальное распределение>>=
def marginalizeOut(self, i):
	'''метод DDist применяется только
	к совместным распределениям, i индекс
	переменной которую мы хотим вынести'''
	d = {}
	for oldK in self.d:
            k = removeElt(oldK, i)
            incrDictEntry(d, k, self.d[oldK])
	return DDist(d)
@

</pre>
<p>
Приведём вспомогательные функции</p>
<pre>
<<вспомогательные функции>>=
def removeElt(k, i):
	'''Удаляет из k  события i элемент'''
	result = k[:i] + k[i+1:] 
	if len(result) == 1: 
		return result[0] 
	else: 
		return result

def incrDictEntry(d, k, v):
	'''В словарь d значение для
	ключа k увеличивает на v''' 
	if k in d: 
		d[k] += v 
	else: 
		d[k] = v

@

</pre>
Проверим 
<pre>
<<prob1.py>>=
PAB = ddist.DDist({("H", "H"):1/4, ("H", "T"):1/4, ("T", "H"):1/4, ("T", "T"):1/4})
PA = PAB.marginalizeOut(1)
print(PA)
@

</pre> 
<p>Получили</p>
<pre>
{"H":0.5, "T":0.5}
</pre>

<h2>Условная вероятность</h2>

<p> <em>Условную вероятность события</em> A при условии, что произошло B,
обозначим \(P(A\mid B)\). Например событие B выпало чётное число
очков на кубике. Событие A выпала 6. Событие B состояний из трёх
равновероятных событий. Событие A одно из трёх.
$$P(A \mid B) = \frac{1}{3}$$
Видим, что для равновероятных событий, условная вероятность равна
отношению числа элементарных событий произведения к числу
элементарных событий события B. Обобщая эти аргументы запишем
$$P(A \mid B) = \frac{P(A \cap B)}{P(B)}$$
И из этой формулы поучаем
$$P(A \cap B) = P(B) P(A \mid B) $$
Если условная вероятность равна безусловной,
$$P(A | B) = P(A)$$
то будем говорить что событие A не зависти от B.
Знание о том, что произошло событие B, не влияет
на оценку вероятности события A.
В этом случае формула произведения выше примет вид
$$P(A \cap B) = P(A)  P(B)$$
Воспользуемся этим правилом для расчёта в следующем случае.
Мы бросаем два кубика: один красный, другой зелёный. Вероятность выпадения на красном 1 равна 1/6, вероятность 
выпадения на зелёном 6 не зависит от того, что выпало на краном
и тоже равна 1/6. Вероятность выпадения этих двух событий одновременно
будет равна произведению этих вероятностей и равна 1/36.
</p>
<p>Рассмотрим <em>условное распределение вероятности</em> \(P(A\mid B)\),
когда A и  B случайные переменные. В этом случае это будет
функция, которая для каждого значения b из B, сопоставляет
распределение для A.
Рассмотрим пример моделирования медицинского теста. 
Случайная переменная D задаёт состояние пациента, принимает одно из двух значений:
болен или здоров. Переменная T результат теста принимает значения: 
положительный или отрицательный. \(P(T \mid D)\) в python получим
<pre>
<<prob1.py>>=
def pTestGivenDis(d):
	if d == "болен":
		return ddist.DDist({"положительный":0.99, "отрицательный":0.01})
	elif d == "здоров":
		return ddist.DDist({"положительный":0.001, "отрицательный":0.999})
	else:
		raise Exception("неправильное значение для D")
@

</pre>
</p>
Распечатаем 
<pre>
<<prob1.py>>=
print(pTestGivenDis("здоров").prob("отрицательный"))
@

</pre>
Получили
<pre>
0.999
</pre>
<p>Зададим функцию, генерирующую совместное распределение 
случайных величин A и B по распределению случайной величины 
B и условному распределению A.
<pre>
<<ddist.py>>=
def JDist(B, AgB):
	'''B распределение случайной величины,
	AgB условное распределение'''
	res = {}
	for b in B.d:
		Agb = AgB(b)
		for a in Agb.d:
			res[descartes(b, a)] = Agb.d[a] * B.d[b]
			
	return DDist(res)

def descartes(a, b):
	'''Вспомогательная функция
	объединяет значения величин в tuple'''
	if type(a) == tuple and type(b) == tuple:
		return a + b
	elif type(a) == tuple:
		return a + (b,)
	elif type(b) == tuple:
		reutrn (a,) + b
	else:
		return (a, b)

@

</pre>
</p>
<p>Рассмотрим пример.
<pre>
<<prob1.py>>=
PA = ddist.DDist({"a1":0.9, "a2":0.1})
def PBgA(a):
	if a == "a1":
		return ddist.DDist({"b1":0.7, "b2":0.3})
	else:
		return ddist.DDist({"b1":0.2, "b2":0.8})

PAB = ddist.JDist(PA, PBgA)
print(PAB)
@

</pre>
Получили
<pre>
{('a1', 'b1'): 0.63, ('a1', 'b2'): 0.27, ('a2', 'b1'): 0.02, ('a2', 'b2'): 0.08}
</pre>
</p>
<p>Пусть у нас есть совместное распределение случайных величин
A, B, мы хотим построить распределение величины A при условии
что величина B=b.</p>
<pre>
<<условие на переменную>>=
def conditionOnVar(self, index, val):
	res = {}
	norm = 0
	for k in self.d:
		if k[index] == val:
			norm += self.prob(k)
	for k in self.d:
		if k[index] == val:
			kn = removeElt(k, index)
			res[kn] = self.prob(k)/norm
	return DDist(res)	
@

</pre>
<pre>
<<prob1.py>>=
print(PAB.conditionOnVar(1, 'b1'))
@
</pre>
Получили
<pre>
{'a1': 0.9692, 'a2': 0.0307}
</pre>
Определим метод класса DDist, который 
создаёт новое условное распределение
<pre>
<<условное распределение>>=
def condDist(self, index):
	return lambda val:self.conditionOnVar(index, val)
@
</pre>
<pre>
<<prob1.py>>=
print(PAB.condDist(1)('b1'))
@
</pre>
